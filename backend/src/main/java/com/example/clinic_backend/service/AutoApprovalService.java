package com.example.clinic_backend.service;

import com.example.clinic_backend.model.PatientRegistration;
import com.example.clinic_backend.repository.PatientRegistrationRepository;
import com.example.clinic_backend.repository.DoctorRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Date;
import java.util.Map;
import java.util.Random;

@Service
@Transactional
public class AutoApprovalService {
    
    @Autowired
    private PatientRegistrationRepository repository;
    
    @Autowired
    private DoctorRepository doctorRepository;
    
    // Config khung gi·ªù m·ªõi (7h-17h)
    private static final String[] TIME_SLOTS = {
        "07:00-08:00", "08:00-09:00", "09:00-10:00", "10:00-11:00", 
        "11:00-12:00", "13:00-14:00", "14:00-15:00", "15:00-16:00", "16:00-17:00"
    };
    
    // S·ªë b·ªánh nh√¢n t·ªëi ƒëa m·ªói khung gi·ªù
    private static final int MAX_PATIENTS_PER_SLOT = 10;
    
    public boolean checkAvailableSlots(Long doctorId, LocalDate appointmentDate, String timeSlot) {
        try {
            System.out.println("üîç Ki·ªÉm tra slot cho b√°c sƒ©: " + doctorId + ", ng√†y: " + appointmentDate + ", khung gi·ªù: " + timeSlot);
            
            // ƒê·∫øm s·ªë ƒë∆°n ƒë√£ ƒë∆∞·ª£c duy·ªát cho b√°c sƒ©, ng√†y v√† khung gi·ªù n√†y
            Integer approvedCount = repository.countByDoctorIdAndAppointmentDateAndAssignedSessionAndStatus(
                doctorId, appointmentDate, timeSlot, "APPROVED"
            );
            
            if (approvedCount == null) {
                approvedCount = 0;
            }
            
            System.out.println("üìä Ki·ªÉm tra slot - " + timeSlot + ": " + approvedCount + "/" + MAX_PATIENTS_PER_SLOT + " ƒë∆°n ƒë∆∞·ª£c duy·ªát");
            
            // Tr·∫£ v·ªÅ true n·∫øu c√≤n slot
            return approvedCount < MAX_PATIENTS_PER_SLOT;
        } catch (Exception e) {
            System.err.println("‚ùå L·ªói khi ki·ªÉm tra slot: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    public PatientRegistration processNewRegistration(PatientRegistration registration) {
        System.out.println("üöÄ AutoApprovalService - X·ª≠ l√Ω ƒëƒÉng k√Ω m·ªõi: " + registration.getFullName());
        
        // N·∫øu ƒë√£ c√≥ assignedSession (t·ª´ frontend), ki·ªÉm tra slot
        if (registration.getDoctorId() != null && registration.getAssignedSession() != null) {
            boolean slotAvailable = checkAvailableSlots(
                registration.getDoctorId(),
                registration.getAppointmentDate(),
                registration.getAssignedSession()
            );
            
            if (slotAvailable) {
                System.out.println("‚úÖ C√≤n slot, ti·∫øn h√†nh auto-approve");
                return autoApproveRegistration(registration, registration.getAssignedSession());
            } else {
                System.out.println("‚ùå H·∫øt slot, chuy·ªÉn sang manual review");
                registration.setStatus("NEEDS_MANUAL_REVIEW");
                registration.setRegistrationNumber(generateRegistrationNumber(registration));
                return repository.save(registration);
            }
        } else {
            // N·∫øu kh√¥ng c√≥ assignedSession, t√¨m slot t·ª± ƒë·ªông
            String availableSlot = findAvailableSlot(registration.getDoctorId(), registration.getAppointmentDate());
            
            if (availableSlot != null) {
                System.out.println("‚úÖ T√¨m th·∫•y slot: " + availableSlot);
                registration.setAssignedSession(availableSlot);
                return autoApproveRegistration(registration, availableSlot);
            } else {
                System.out.println("‚ùå Kh√¥ng t√¨m th·∫•y slot n√†o");
                registration.setStatus("NEEDS_MANUAL_REVIEW");
                registration.setRegistrationNumber(generateRegistrationNumber(registration));
                return repository.save(registration);
            }
        }
    }
    
    private String findAvailableSlot(Long doctorId, LocalDate appointmentDate) {
        for (String timeSlot : TIME_SLOTS) {
            boolean available = checkAvailableSlots(doctorId, appointmentDate, timeSlot);
            if (available) {
                System.out.println("üéØ T√¨m th·∫•y slot kh·∫£ d·ª•ng: " + timeSlot);
                return timeSlot;
            }
        }
        return null;
    }
    
    // QUAN TR·ªåNG: S·ª¨A L·∫†I METHOD N√ÄY - G√ÅN S·ªê TH·ª® T·ª∞ ƒê√öNG C√ÅCH
    public PatientRegistration autoApproveRegistration(PatientRegistration registration, String timeSlot) {
        System.out.println("üöÄ B·∫Øt ƒë·∫ßu t·ª± ƒë·ªông duy·ªát ƒë∆°n - Khung gi·ªù: " + timeSlot);
        
        try {
            // QUAN TR·ªåNG: G√°n s·ªë th·ª© t·ª± TR∆Ø·ªöC KHI set status APPROVED
            assignQueueAndTimeSlot(registration, timeSlot);
            
            // Generate c√°c th√¥ng tin kh√°c
            registration.setRegistrationNumber(generateRegistrationNumber(registration));
            registration.setTransactionNumber(generateTransactionNumber());
            registration.setPatientCode(generatePatientCode(registration));
            
            // L·∫•y th√¥ng tin ph√≤ng t·ª´ b√°c sƒ©
            if (registration.getDoctorId() != null) {
                doctorRepository.findById(registration.getDoctorId()).ifPresent(doctor -> {
                    registration.setRoomNumber(doctor.getRoomNumber());
                    System.out.println("üè• Set room number from doctor: " + doctor.getRoomNumber());
                });
            }
            
            registration.setExaminationFee(calculateFee(registration));
            registration.setInsuranceType("Kh√¥ng BHYT");
            
            // QUAN TR·ªåNG: Set status APPROVED SAU C√ôNG
            registration.setStatus("APPROVED");
            registration.setAutoApproved(true);
            registration.setApprovedAt(LocalDateTime.now());
            registration.setAssignedSession(timeSlot);
            
            PatientRegistration saved = repository.save(registration);
            
            System.out.println("üéâ ƒê√£ t·ª± ƒë·ªông duy·ªát th√†nh c√¥ng!");
            System.out.println("üìã Th√¥ng tin cu·ªëi c√πng:");
            System.out.println("   - M√£ phi·∫øu: " + saved.getRegistrationNumber());
            System.out.println("   - S·ªë th·ª© t·ª±: " + saved.getQueueNumber());
            System.out.println("   - Khung gi·ªù: " + saved.getAssignedSession());
            System.out.println("   - Tr·∫°ng th√°i: " + saved.getStatus());
            
            return saved;
        } catch (Exception e) {
            System.err.println("‚ùå L·ªói khi t·ª± ƒë·ªông duy·ªát: " + e.getMessage());
            e.printStackTrace();
            registration.setStatus("NEEDS_MANUAL_REVIEW");
            return repository.save(registration);
        }
    }
    
    // QUAN TR·ªåNG: S·ª¨A L·∫†I METHOD N√ÄY - ƒê·∫æM TR∆Ø·ªöC KHI C√ì ƒê∆†N HI·ªÜN T·∫†I
    private void assignQueueAndTimeSlot(PatientRegistration registration, String timeSlot) {
        LocalDate appointmentDate = registration.getAppointmentDate();
        Long doctorId = registration.getDoctorId();
        
        System.out.println("üîç ƒêang ƒë·∫øm s·ªë ƒë∆°n approved TR∆Ø·ªöC KHI ƒë∆°n hi·ªán t·∫°i ƒë∆∞·ª£c duy·ªát:");
        System.out.println("   - B√°c sƒ©: " + doctorId);
        System.out.println("   - Ng√†y: " + appointmentDate);
        System.out.println("   - Khung gi·ªù: " + timeSlot);
        
        // QUAN TR·ªåNG: ƒê·∫øm s·ªë ƒë√£ approved TR∆Ø·ªöC KHI ƒë∆°n hi·ªán t·∫°i ƒë∆∞·ª£c approve
        // ƒê∆°n hi·ªán t·∫°i v·∫´n ƒëang c√≥ status = null ho·∫∑c PROCESSING
        Integer approvedCount = repository.countByDoctorIdAndAppointmentDateAndAssignedSessionAndStatus(
            doctorId, appointmentDate, timeSlot, "APPROVED"
        );
        
        if (approvedCount == null) {
            approvedCount = 0;
        }
        
        // S·ªë th·ª© t·ª± = s·ªë ƒë√£ approved + 1
        int queueNumber = approvedCount + 1;
        registration.setQueueNumber(queueNumber);
        registration.setExpectedTimeSlot(timeSlot);
        
        System.out.println("üéØ ƒê√£ c√≥ " + approvedCount + " ƒë∆°n approved tr∆∞·ªõc ƒë√≥");
        System.out.println("üéØ S·ªë th·ª© t·ª± c·ªßa ƒë∆°n hi·ªán t·∫°i: " + queueNumber);
        
        // DEBUG: Ki·ªÉm tra xem c√≥ ƒë∆°n n√†o ƒë√£ approved kh√¥ng
        if (approvedCount > 0) {
            System.out.println("‚ö†Ô∏è C√ì " + approvedCount + " ƒê∆†N ƒê√É APPROVED TR∆Ø·ªöC ƒê√ì!");
        } else {
            System.out.println("‚úÖ ƒê√¢y l√† ƒë∆°n ƒë·∫ßu ti√™n - s·ªë th·ª© t·ª± s·∫Ω l√† 1");
        }
    }
    
    private String generateRegistrationNumber(PatientRegistration reg) {
        try {
            String datePart = new SimpleDateFormat("ddMMyy").format(new Date());
            Long dailyCount = repository.countByCreatedAtToday();
            if (dailyCount == null) dailyCount = 0L;
            return "U" + datePart + String.format("%04d", dailyCount + 1);
        } catch (Exception e) {
            System.err.println("‚ùå L·ªói generate m√£ phi·∫øu: " + e.getMessage());
            return "U" + System.currentTimeMillis();
        }
    }
    
    private String generateTransactionNumber() {
        try {
            String timePart = new SimpleDateFormat("yyMMddHHmm").format(new Date());
            Random random = new Random();
            String randomPart = String.format("%03d", random.nextInt(1000));
            return timePart + randomPart;
        } catch (Exception e) {
            System.err.println("‚ùå L·ªói generate m√£ giao d·ªãch: " + e.getMessage());
            return "TXN" + System.currentTimeMillis();
        }
    }
    
    private String generatePatientCode(PatientRegistration reg) {
        try {
            String yearPart = new SimpleDateFormat("yy").format(new Date());
            Long yearlyCount = repository.countByYear(2024);
            if (yearlyCount == null) yearlyCount = 0L;
            return "N" + yearPart + "-" + String.format("%06d", yearlyCount + 1);
        } catch (Exception e) {
            System.err.println("‚ùå L·ªói generate m√£ b·ªánh nh√¢n: " + e.getMessage());
            return "N" + System.currentTimeMillis();
        }
    }
    
    private BigDecimal calculateFee(PatientRegistration reg) {
        return new BigDecimal("250000");
    }
}